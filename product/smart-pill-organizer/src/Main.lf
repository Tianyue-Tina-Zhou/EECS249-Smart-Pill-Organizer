target C;
main reactor Main {
    preamble {=
        #include "pico/stdlib.h"
        #include "pico/binary_info.h"
        #include "LCD_1in14_V2.h"
        #include "DEV_Config.h"
        #include "GUI_Paint.h"
        #include "Debug.h"

        #include "Infrared.h"
		#include "TCS34725.h"
        #include "icm20948.h"
        #include <math.h>

        #include "pico/multicore.h"
        #include "hardware/irq.h"

        // PINs

        #define LCD_BUTTON_PIN_A        15
        #define LCD_BUTTON_PIN_B        17
        #define LCD_BUTTON_PIN_UP       2
        #define LCD_BUTTON_PIN_DOWN     18
        #define LCD_BUTTON_PIN_LEFT     16
        #define LCD_BUTTON_PIN_RIGHT    20
        #define LCD_BUTTON_PIN_CENTER   3
        #define EXTRA_PUSH_BUTTON_PIN   28

        const uint PIN_MODE_BUTTON = LCD_BUTTON_PIN_A;
        const uint PIN_FUNC_BUTTON = LCD_BUTTON_PIN_B;
        const uint PIN_PEN_BUTTON = EXTRA_PUSH_BUTTON_PIN;
        const uint PIN_CALIBRATE_BUTTON = LCD_BUTTON_PIN_RIGHT;
        
        UWORD *BlackImage;
        int count = 0;


        // Buttons
        bool isPenButtonPressed = false;
        bool isModeButtonPressed = false;
        bool isFuncButtonPressed = false;
        bool isCalibrateButtonPressed = false;

        bool isModeButtonClick = false;
        bool isFuncButtonClick = false;
        bool isCalibrateButtonClick = false;

        char serialOutput[200];
        bool hasNewSerialOutput = false;

        bool senderReady = true;
        UWORD RGB565;

        // FSM
        int curr_state = 0;
        char state_display[5];
        UDOUBLE last_color = 0;
        bool updated_for_paint = false;

        #define STATE_COLOR_SENSING     0
        #define STATE_PAINTING    1

        #define CMD_COLOR  0
        #define CMD_MOTION  1
        #define CMD_UNDO 2
        #define CMD_CALIBRATE 3

        #define MULTI_CORE_CMD_SERIAL_OUTPUT 1
        #define MULTI_CORE_CMD_LCD_UPDATE 2


        // IMU Data Pointers
        IMU_EN_SENSOR_TYPE enMotionSensorType;
        IMU_ST_ANGLES_DATA stAngles;

        // Initialization Functions
        int init_lcd() {
            if(DEV_Module_Init()!=0){
                return -1;
            }
            DEV_SET_PWM(50);
            
            // LCD Init
            LCD_1IN14_V2_Init(HORIZONTAL);
            LCD_1IN14_V2_Clear(WHITE);

            UDOUBLE Imagesize = LCD_1IN14_V2_HEIGHT * LCD_1IN14_V2_WIDTH * 2;
            if((BlackImage = (UWORD *)malloc(Imagesize)) == NULL) {
                return 1;
            }
            Paint_NewImage((UBYTE *) BlackImage, LCD_1IN14_V2.WIDTH, LCD_1IN14_V2.HEIGHT, 0, WHITE);
            Paint_SetScale(65);
            Paint_Clear(WHITE);
            Paint_SetRotate(ROTATE_180);
            Paint_Clear(WHITE);

            DEV_SET_PWM(10);
        }
		
		void init_color_sensor() {
            TCS34725_Init();
			DEV_SET_PWM(50);
		
		}

        void init_gpio() {
            gpio_init(PIN_MODE_BUTTON);
            gpio_set_dir(PIN_MODE_BUTTON, GPIO_IN);
            gpio_pull_up(PIN_MODE_BUTTON);

            gpio_init(PIN_FUNC_BUTTON);
            gpio_set_dir(PIN_FUNC_BUTTON, GPIO_IN);
            gpio_pull_up(PIN_FUNC_BUTTON);

            gpio_init(PIN_CALIBRATE_BUTTON);
            gpio_set_dir(PIN_CALIBRATE_BUTTON, GPIO_IN);
            gpio_pull_up(PIN_CALIBRATE_BUTTON);

            gpio_init(PIN_PEN_BUTTON);
            gpio_set_dir(PIN_PEN_BUTTON, GPIO_IN);
        }

        void init_imu()
        {
            imuInit(&enMotionSensorType);
        }
		
		void lcd_show_color(UWORD color)
        {   
            Paint_DrawRectangle(0, 0, LCD_1IN14_V2.WIDTH, LCD_1IN14_V2.HEIGHT, color, DOT_PIXEL_2X2,DRAW_FILL_FULL);
            Paint_DrawString_EN(80, 57, state_display, &Font20, WHITE, BLACK);
            LCD_1IN14_V2_Display(BlackImage);
        }

        // Core 1 interrupt Handler
        void core1_interrupt_handler() {

            // Receive CMD, and execute the corresponding I/O
            while (multicore_fifo_rvalid()){
                int cmd = multicore_fifo_pop_blocking();
                if (cmd == MULTI_CORE_CMD_SERIAL_OUTPUT) {
                    printf("%s", serialOutput);
                }
                else if (cmd == MULTI_CORE_CMD_LCD_UPDATE) {
                    lcd_show_color(RGB565);
                }

                senderReady = true;        
            }

            multicore_fifo_clear_irq(); // Clear interrupt
        }

        void update_serial_output() {
            if (hasNewSerialOutput) {
                printf("%s", serialOutput);
                hasNewSerialOutput = false;
            }
        }

        void sample_push_buttons() {
            isPenButtonPressed = gpio_get(PIN_PEN_BUTTON);
        
            bool new_mode_value = gpio_get(PIN_MODE_BUTTON);
            if(!new_mode_value && isModeButtonPressed) {
                isModeButtonClick = true;
            }
            isModeButtonPressed = new_mode_value;
            
            bool new_func_value = gpio_get(PIN_FUNC_BUTTON);
            if(!new_func_value && isFuncButtonPressed) {
                isFuncButtonClick = true;
            }
            isFuncButtonPressed = new_func_value;

            bool new_calibrate_value = gpio_get(PIN_CALIBRATE_BUTTON);
            if(!new_calibrate_value && isCalibrateButtonPressed)  {
                isCalibrateButtonClick = true;
            }
            isCalibrateButtonPressed = new_calibrate_value;
        }

        void update_lcd() {
            if (curr_state == STATE_COLOR_SENSING) {
                RGB color = TCS34725_Get_RGBData();
                last_color = TCS34725_GetRGB888(color);
                UWORD lcdColor = TCS34725_GetRGB565(color);
                lcd_show_color(lcdColor);
                updated_for_paint = false;
            } 
            else if (!updated_for_paint) {
                lcd_show_color(WHITE);
                updated_for_paint = true;
            }
        }

        // Core 1 Main Code
        void core1_entry() {
            while (1){
                update_serial_output();
                sample_push_buttons();
                update_lcd();
                
                sleep_ms(50);
            }
        }

    =}
    
    reaction(startup) {=
        stdio_init_all();
        init_gpio();
        init_lcd();
		init_color_sensor();
        init_imu();
        multicore_launch_core1(core1_entry);
    =}

    timer FSM_timer(3 sec, 50 msec)
    reaction(FSM_timer){=
        int next_state = curr_state; 
        switch(curr_state){
            case STATE_COLOR_SENSING:
                sprintf(state_display, "COLOR");
                if (isModeButtonClick) {
                    next_state = STATE_PAINTING;
                    isModeButtonClick = false;
                }
            break;
            case STATE_PAINTING:
                sprintf(state_display, "PAINT");
                if (isModeButtonClick){
                    next_state = STATE_COLOR_SENSING;
                    isModeButtonClick = false;
                }
            break;
        }

        curr_state = next_state;
    =}


    timer painting_timer(1 sec, 50 msec)
    reaction(painting_timer) {=
        if(curr_state == STATE_PAINTING){
            imuDataGet( &stAngles, NULL, NULL, NULL);
            
            if (isFuncButtonClick) {
                // UNDO
                sprintf(serialOutput, "<C>%d</C>", CMD_UNDO);
                isFuncButtonClick = false;
                hasNewSerialOutput = true;
            }
            else if (isCalibrateButtonClick) {
                // CALIBRATE
                sprintf(serialOutput, "<C>%d</C>", CMD_CALIBRATE);
                isCalibrateButtonClick = false;
                hasNewSerialOutput = true;
            }
            else {
                // MOTION
                int stroke = isPenButtonPressed ? 1 : 0;
                sprintf(serialOutput, "<C>%d %d %f %f %f</C>", CMD_MOTION, stroke, stAngles.fRoll, stAngles.fPitch, stAngles.fYaw);
                hasNewSerialOutput = true;
            }
        }
    =}


    timer color_Sensing(1 sec, 100 msec)
    reaction(color_Sensing) {=
        if(curr_state == STATE_COLOR_SENSING){
            // RGB rgb = TCS34725_Get_RGBData();
            // UDOUBLE RGB888 = TCS34725_GetRGB888(rgb);
            // RGB565 = TCS34725_GetRGB565(rgb);

            //printf("Color sensed in RGB565 %X, RGB888 %X!\r\n", RGB565, RGB888);
            //multicore_fifo_push_blocking(2);
            //senderReady = false;            // lcd_show_color(RGB565);
            
            if (isPenButtonPressed) {
                sprintf(serialOutput, "<C>%d %X</C>", CMD_COLOR, last_color);
                hasNewSerialOutput = true;
            }
        }
    =}
}