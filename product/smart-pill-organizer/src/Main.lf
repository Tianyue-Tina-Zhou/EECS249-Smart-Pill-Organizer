target C;
main reactor Main {
    preamble {=
        #include "pico/stdlib.h"
        #include "pico/binary_info.h"
        #include "LCD_1in14_V2.h"
        #include "DEV_Config.h"
        #include "GUI_Paint.h"
        #include "Debug.h"

        #include "Infrared.h"
		#include "TCS34725.h"
        #include "icm20948.h"
        #include <math.h>

        #include "pico/multicore.h"
        #include "hardware/irq.h"

        #define sample_size 20
        #define accel_threshold 300
        #define debounceDelay 50

        // Global Variables
        //joystick & BUTTON AB
        const uint keyA = 15; 
        const uint keyB = 17; 

        //const uint up = 2;
        //const uint left = 16;
        //const uint ctrl = 3;
        // const uint right = 20;
        //const uint down = 18;
        
        const uint LED_PIN = 25;
        const uint PB3_PIN = 28;
        
        bool led = true;
        UWORD *BlackImage;
        int count = 0;


        // Buttons
        bool PB3_Pressed = false;
        bool A_Pressed = false;
        bool B_Pressed = false;

        char IMUData[200]; 
        bool senderReady = true;
        UWORD RGB565;

        // FSM
        int curr_state = 0;

        #define SENSING     0
        #define PAINTING    1
        
        #define FUNC        B_Pressed
        #define MODE        A_Pressed
        #define PEN         PB3_Pressed


        // IMU Data Pointers
        IMU_EN_SENSOR_TYPE enMotionSensorType;
        IMU_ST_ANGLES_DATA stAngles;

        // Initialization Functions
        int lcd_init() {
            if(DEV_Module_Init()!=0){
                return -1;
            }
            DEV_SET_PWM(50);
            
            // LCD Init
            LCD_1IN14_V2_Init(HORIZONTAL);
            LCD_1IN14_V2_Clear(WHITE);

            UDOUBLE Imagesize = LCD_1IN14_V2_HEIGHT * LCD_1IN14_V2_WIDTH * 2;
            if((BlackImage = (UWORD *)malloc(Imagesize)) == NULL) {
                return 1;
            }
        }
		
		void color_sensing_init() {
            TCS34725_Init();
			DEV_SET_PWM(50);
		
		}

        void init_gpio() {
            gpio_init(LED_PIN);
            gpio_set_dir(LED_PIN, GPIO_OUT);
            gpio_init(PB3_PIN);
            gpio_set_dir(PB3_PIN, GPIO_IN);
            
            gpio_init(keyA);
            gpio_set_dir(keyA, GPIO_IN);
            gpio_pull_up(keyA);
            gpio_init(keyB);
            gpio_set_dir(keyB, GPIO_IN);
            gpio_pull_up(keyB);
        }

        void init_imu()
        {
            imuInit(&enMotionSensorType);
        }


        // Helper functions
        void lcd_print(const char * pString)
        {   
            // 1.Create a new image cache named BlackImage and fill it with white
            Paint_NewImage((UBYTE *) BlackImage, LCD_1IN14_V2.WIDTH, LCD_1IN14_V2.HEIGHT, 0, WHITE);
            Paint_SetScale(65);
            Paint_Clear(WHITE);
            Paint_SetRotate(ROTATE_0);
            Paint_Clear(WHITE);
            
            // 2.Drawing on the image
            Paint_DrawString_EN(20, 20, pString, &Font20, WHITE, BLACK);

            // 3.Refresh the picture in RAM to LCD
            LCD_1IN14_V2_Display(BlackImage);
            DEV_SET_PWM(10);
        }
		
		void lcd_show_color(UWORD color)
        {   
            // 1.Create a new image cache named BlackImage and fill it with white
            Paint_NewImage((UBYTE *) BlackImage, LCD_1IN14_V2.WIDTH, LCD_1IN14_V2.HEIGHT, 0, WHITE);
            Paint_SetScale(65);
            Paint_Clear(WHITE);
            Paint_SetRotate(ROTATE_0);
            Paint_Clear(WHITE);
            
            // 2.Drawing on the image
			Paint_DrawString_EN(20, 20, "Color collected", &Font20, WHITE, BLACK);
            Paint_DrawRectangle(45, 60, 180, 90, color, DOT_PIXEL_2X2,DRAW_FILL_FULL);

            // 3.Refresh the picture in RAM to LCD
            LCD_1IN14_V2_Display(BlackImage);
            DEV_SET_PWM(10);
        }
        // Core 1 interrupt Handler
        void core1_interrupt_handler() {

            // Receive Raw Value, Convert and Print Temperature Value
            while (multicore_fifo_rvalid()){
                int temp = multicore_fifo_pop_blocking();
                if (temp == 1)
                {
                    printf("%s", IMUData);
                }
                else
                {
                    lcd_show_color(RGB565);
                }
                senderReady = true;        
            }

            multicore_fifo_clear_irq(); // Clear interrupt
        }

        // Core 1 Main Code
        void core1_entry() {
            // Configure Core 1 Interrupt
            multicore_fifo_clear_irq();
            irq_set_exclusive_handler(SIO_IRQ_PROC1, core1_interrupt_handler);

            irq_set_enabled(SIO_IRQ_PROC1, true);

            // Infinte While Loop to wait for interrupt
            while (1){
                tight_loop_contents();
            }
        }

    =}
    
    reaction(startup) {=
        stdio_init_all();
        init_gpio();
        lcd_init();
		color_sensing_init();
        init_imu();
        multicore_launch_core1(core1_entry);

        // printf("System Initialized!\r\n");
    =}

    timer blink_led(100 msec, 200 msec)
    reaction(blink_led) {=
        gpio_put(LED_PIN, led);
        led = !led;
    =}
	
    timer pb_sampling(100 msec, 150 msec)
    reaction(pb_sampling) {=
        PB3_Pressed = gpio_get(PB3_PIN);
        
        if(!gpio_get(keyA)) A_Pressed = true;

        if(!gpio_get(keyB)) B_Pressed = true;

        // sleepdebounceDelay
    =}

   // timer motion_detection(3 sec, 50 msec)
    //reaction(motion_detection) {=
      //  printf("<C>3 %d %f %f %f</C>", A_Pressed ? 1 : 0, stAngles.fRoll, stAngles.fPitch, stAngles.fYaw);
    // =}


    timer FSM_timer(3 sec, 50 msec)
    reaction(FSM_timer){=
        int next_state = curr_state; 
        switch(curr_state){
            case SENSING:
                if(MODE) {
                    next_state = PAINTING;
                    MODE = false;
                    static char display_buf[16];
                    snprintf(display_buf, 16, "PAINTING");
                    // lcd_print(display_buf);
                }
            break;
            case PAINTING:
                if(MODE){
                    next_state = SENSING;
                    MODE = false;
                }
            break;
        }
        // printf("STATE: %d \r\n", next_state);
        curr_state = next_state;
    =}


    timer painting_timer(1 sec, 50 msec)
    reaction(painting_timer) {=
        if (senderReady) {
            if(curr_state == PAINTING){
                imuDataGet( &stAngles, NULL, NULL, NULL);
                if (FUNC) {
                    // Undo
                    sprintf(IMUData, "<C>2</C>");
                    
                    FUNC = false;
                }
                else if (PEN) {
                    // Paint
                    sprintf(IMUData, "<C>1 1 %f %f %f</C>", stAngles.fRoll, stAngles.fPitch, stAngles.fYaw);
                } else {
                    // Paint
                    sprintf(IMUData, "<C>1 0 %f %f %f</C>", stAngles.fRoll, stAngles.fPitch, stAngles.fYaw);
                }
                multicore_fifo_push_blocking(1);
                senderReady = false;
            }
        }
    =}


    timer color_Sensing(1 sec, 100 msec)
    reaction(color_Sensing) {=
        if(curr_state == SENSING){
            RGB rgb = TCS34725_Get_RGBData();
            UDOUBLE RGB888 = TCS34725_GetRGB888(rgb);
            RGB565 = TCS34725_GetRGB565(rgb);

            printf("Color sensed in RGB565 %X, RGB888 %X!\r\n", RGB565, RGB888);
            multicore_fifo_push_blocking(2);
            senderReady = false;            // lcd_show_color(RGB565);
            // printf("Sensing color\r\n");
        }
    =}
}