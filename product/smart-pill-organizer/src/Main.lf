target C{keepalive:true};
main reactor Main {
    preamble {=
        #include "pico/stdlib.h"
        #include "pico/binary_info.h"
        #include "LCD_1in14_V2.h"
        #include "DEV_Config.h"
        #include "GUI_Paint.h"
        #include "Debug.h"

        #include "Infrared.h"
		#include "TCS34725.h"
        #include "icm20948.h"
        #include <math.h>


        #define sample_size 20
        #define accel_threshold 300

        // Global Variables
        //joystick & BUTTON AB
        const uint keyA = 15; 
        const uint keyB = 17; 

        //const uint up = 2;
        //const uint left = 16;
        //const uint ctrl = 3;
        //const uint right = 20;
        //const uint down = 18;
        
        const uint LED_PIN = 25;
        const uint PB3_PIN = 28;
        
        bool led = true;
        UWORD *BlackImage;
        int count = 0;
        bool PB3_Pressed = false;
        //bool A_Pressed = false;
        //bool B_Pressed = false;
        const char * CMD_PREFIX = "<C>";


        // IMU Data Pointers
        IMU_EN_SENSOR_TYPE enMotionSensorType;
	    IMU_ST_SENSOR_DATA stAccelRawData;
        IMU_ST_SENSOR_DATA stGyroRawData;
        IMU_ST_ANGLES_DATA stAngles;
        IMU_ST_SENSOR_DATA stMagnRawData;

        int prev_x, prev_y;
        // const int accel_threshold = 500;
        //const int sample_size = 10;
        int x_samples[sample_size];
        int y_samples[sample_size];
        int delta_x, delta_y;
        int x_v, y_v;


        


        // Initialization Functions
        int lcd_init() {
            if(DEV_Module_Init()!=0){
                return -1;
            }
            DEV_SET_PWM(50);
            
            // LCD Init
            LCD_1IN14_V2_Init(HORIZONTAL);
            LCD_1IN14_V2_Clear(WHITE);

            UDOUBLE Imagesize = LCD_1IN14_V2_HEIGHT * LCD_1IN14_V2_WIDTH * 2;
            if((BlackImage = (UWORD *)malloc(Imagesize)) == NULL) {
                // Failed to apply for black memory...
                return 1;
            }
        }
		
		void color_sensing_init() {
            TCS34725_Init();
			DEV_SET_PWM(50);
			
		}

        void init_gpio() {
            
            gpio_init(LED_PIN);
            gpio_set_dir(LED_PIN, GPIO_OUT);
            gpio_init(PB3_PIN);
            gpio_set_dir(PB3_PIN, GPIO_IN);
            
            gpio_init(keyA);
            gpio_set_dir(keyA, GPIO_IN);
            gpio_pull_up(keyA);
            gpio_init(keyB);
            gpio_set_dir(keyB, GPIO_IN);
            gpio_pull_up(keyB);

        }

        void init_imu()
        {
            imuInit(&enMotionSensorType);
        }


        // Helper functions
        void lcd_print(const char * pString)
        {   
            // 1.Create a new image cache named BlackImage and fill it with white
            Paint_NewImage((UBYTE *) BlackImage, LCD_1IN14_V2.WIDTH, LCD_1IN14_V2.HEIGHT, 0, WHITE);
            Paint_SetScale(65);
            Paint_Clear(WHITE);
            Paint_SetRotate(ROTATE_0);
            Paint_Clear(WHITE);
            
            // 2.Drawing on the image
            Paint_DrawString_EN(20, 20, pString, &Font20, WHITE, BLACK);

            // 3.Refresh the picture in RAM to LCD
            LCD_1IN14_V2_Display(BlackImage);
            DEV_SET_PWM(10);
        }
		
		void lcd_show_color(UWORD color)
        {   
            // 1.Create a new image cache named BlackImage and fill it with white
            Paint_NewImage((UBYTE *) BlackImage, LCD_1IN14_V2.WIDTH, LCD_1IN14_V2.HEIGHT, 0, WHITE);
            Paint_SetScale(65);
            Paint_Clear(WHITE);
            Paint_SetRotate(ROTATE_0);
            Paint_Clear(WHITE);
            
            // 2.Drawing on the image
			Paint_DrawString_EN(20, 20, "Color collected", &Font20, WHITE, BLACK);
            Paint_DrawRectangle(45, 60, 180, 90, color, DOT_PIXEL_2X2,DRAW_FILL_FULL);

            // 3.Refresh the picture in RAM to LCD
            LCD_1IN14_V2_Display(BlackImage);
            DEV_SET_PWM(10);
        }

        void* A_ptr;
        void* B_ptr;

        void botton_irq(uint gpio, uint32_t events){
            if(gpio == keyA){
                if(events == GPIO_IRQ_EDGE_FALL){
                    //A_Pressed = true;
                    schedule(A_ptr, 0);
                }
                //if(events == GPIO_IRQ_EDGE_RISE){
                //    A_Pressed = false;
                //}
            }
            if(gpio == keyB){
                if(events == GPIO_IRQ_EDGE_FALL){
                    //B_Pressed = true;
                    schedule(B_ptr, 0);
                }
                //if(events == GPIO_IRQ_EDGE_RISE){
                //    B_Pressed = false;
                //}
            }
        }
    

    =}
    
    reaction(startup) {=
        stdio_init_all();
        init_gpio();
        lcd_init();
		color_sensing_init();
        init_imu();

        gpio_set_irq_enabled_with_callback(keyA, GPIO_IRQ_EDGE_FALL, true, botton_irq);
        //gpio_set_irq_enabled_with_callback(keyA, GPIO_IRQ_EDGE_RISE, true, botton_irq);
        gpio_set_irq_enabled_with_callback(keyB, GPIO_IRQ_EDGE_FALL, true, botton_irq);
        //gpio_set_irq_enabled_with_callback(keyB, GPIO_IRQ_EDGE_RISE, true, botton_irq);
        //gpio_set_irq_enabled_with_callback(keyA, EDGEHIGH, true, irq_A_release);
        // printf("System Initialized!\r\n");
    =}


    // to check physical action: uncomment the following codes
    
    physical action A:bool;
    physical action B:bool;



    
    reaction(startup)->A,  B {=
        A_ptr = A;
        B_ptr = B;
    =}

    reaction(A) {=
         //static char display_buf[16];
         //snprintf(display_buf, 16, "A is pressed ");
         //lcd_print(display_buf);
        //display_buf = "A is pressed";
        printf("AAAAAAAAAAAA");
    =}


    



    timer blink_led(100 msec, 50 msec)
    reaction(blink_led) {=
        gpio_put(LED_PIN, led);
        led = !led;
    =}
	
    timer pb_sampling(100 msec, 50 msec)
    reaction(pb_sampling) {=
        PB3_Pressed = gpio_get(PB3_PIN);

        //printf("A Pressed: %d\n", A_Pressed);
        //printf("PB3 Pressed: %d\n", PB3_Pressed);
    =}
    
    
    timer lcd_refresh(100 msec, 50 msec)
    reaction(lcd_refresh) {=
         static char display_buf[16];     
        //snprintf(display_buf, 16, "A: %d; B: %d", A_Pressed, B_Pressed);
         snprintf(display_buf, 16, "WORK!");
         lcd_print(display_buf);
    =}
    

    
    // timer imu_fetch(1 sec, 5 msec)
    // reaction(imu_fetch) {=
    //     sample_accel_save_in_buffer();
    // =}

    timer motion_detection(3 sec, 50 msec)
    reaction(motion_detection) {=
        // printf("----------------\n");
        // if (abs(delta_x) >= accel_threshold || abs(delta_y) >= accel_threshold) {
        //     printf("Delta X: %d     Delta Y: %d\r\n", delta_x, delta_y);
        //     if (delta_x >= accel_threshold) {
        //         printf("UP  ");
        //     } else if (delta_x <= -accel_threshold) {
        //         printf("DOWN  ");
        //     }

        //     if (delta_y >= accel_threshold) {
        //         printf("RIGHT  ");
        //     } else if (delta_y <= -accel_threshold) {
        //         printf("LEFT  ");
        //     }
        //     delta_x = 0;
        //     delta_y = 0;
        //     printf("\r\n\n");
        // }
        // if (abs(x_v) >= accel_threshold || abs(y_v) >= accel_threshold) {
            //printf("X_V: %d     Y_V: %d\r\n", x_v, y_v);
            //printf("<C>1 0 %d %d</C>", check_bound(y_v), check_bound(x_v));
            // if (x_v >= accel_threshold) {
            //     printf("UP  ");
            // } else if (x_v <= -accel_threshold) {
            //     printf("DOWN  ");
            // }

            // if (y_v >= accel_threshold) {
            //     printf("RIGHT  ");
            // } else if (y_v <= -accel_threshold) {
            //     printf("LEFT  ");
            // }
            // // delta_x = 0;
            // // delta_y = 0;
            // printf("\r\n\n");
        // }
		// printf("Roll: %.2f     Pitch: %.2f     Yaw: %.2f \r\n",stAngles.fRoll, stAngles.fPitch, stAngles.fYaw);
        // printf("----------------------------------------------------\r\n");
        // printf("Acceleration: X: %d     Y: %d     Z: %d \r\n",stAccelRawData.s16X, stAccelRawData.s16Y, stAccelRawData.s16Z);
        imuDataGet(&stAngles, &stGyroRawData, &stAccelRawData, &stMagnRawData);
		printf("Gyroscope: X: %d     Y: %d     Z: %d \r\n", stGyroRawData.s16X, stGyroRawData.s16Y, stGyroRawData.s16Z);
    =}

    // timer color_Sensing(0 sec, 1000 msec)
	// reaction(color_Sensing) {=
	// 	RGB rgb=TCS34725_Get_RGBData();
	// 	UWORD RGB565=TCS34725_GetRGB565(rgb);
    //     UDOUBLE RGB888=TCS34725_GetRGB888(rgb);
	// 	printf("Color sensed in RGB565 %X, RGB888 %X!\r\n", RGB565, RGB888);
    //     lcd_show_color(RGB565);
    // =}
}

